<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Getting Started: Serving Web Content</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>
<script src="//cdn.rawgit.com/dcodeIO/protobuf.js/6.X.X/dist/protobuf.min.js"></script>
<script>
    function toUTF8Array(str) {
        var utf8 = [];
        for (var i=0; i < str.length; i++) {
            var charcode = str.charCodeAt(i);
            if (charcode < 0x80) utf8.push(charcode);
            else if (charcode < 0x800) {
                utf8.push(0xc0 | (charcode >> 6),
                    0x80 | (charcode & 0x3f));
            }
            else if (charcode < 0xd800 || charcode >= 0xe000) {
                utf8.push(0xe0 | (charcode >> 12),
                    0x80 | ((charcode>>6) & 0x3f),
                    0x80 | (charcode & 0x3f));
            }
            // surrogate pair
            else {
                i++;
                // UTF-16 encodes 0x10000-0x10FFFF by
                // subtracting 0x10000 and splitting the
                // 20 bits of 0x0-0xFFFFF into two halves
                charcode = 0x10000 + (((charcode & 0x3ff)<<10)
                    | (str.charCodeAt(i) & 0x3ff));
                utf8.push(0xf0 | (charcode >>18),
                    0x80 | ((charcode>>12) & 0x3f),
                    0x80 | ((charcode>>6) & 0x3f),
                    0x80 | (charcode & 0x3f));
            }
        }
        return utf8;
    }

    function httpGet(theUrl) {
        console.time("httpGetTotal")
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open("GET", theUrl, true); // false for synchronous request
        // xmlHttp.responseType = "arraybuffer";

        // via Cache-Control header:
        xmlHttp.setRequestHeader("Cache-Control", "no-cache, no-store, max-age=0");
        // fallbacks for IE and older browsers:
        xmlHttp.setRequestHeader("Expires", "Tue, 01 Jan 1980 1:00:00 GMT");
        xmlHttp.setRequestHeader("Pragma", "no-cache"); //Edit: I noticed this is required for Chrome some time ago... forgot to mention here

        xmlHttp.responseType = "arraybuffer";

        xmlHttp.onload = (event) => {
            console.timeEnd("httpGetLoadResponse")
            console.time("httpGetParseOverhead")
            const arrayBuffer = xmlHttp.response; // Note: not req.responseText
            if (arrayBuffer) {
                console.time("httpGetCastUint8Array")
                const byteArray = new Uint8Array(arrayBuffer);
                console.timeEnd("httpGetCastUint8Array")
                // console.log(byteArray)
                // console.log(typeof byteArray)
                // byteArray.forEach((element, index) => {
                //     // do something with each byte in the array
                // });
                console.time("httpGetDecodeProto")
                protobuf.load("/statesProto.proto", function(err, root) {

                    // Retrieve the type of message I want to decode from the .proto file
                    var MyMessage = root.lookupType("States");

                    // Finally I can decode my message
                    var message = MyMessage.decode(byteArray);
                    // console.log(message)
                    // endTime = new Date();
                    // console.log("elapsed time: " + (endTime - startTime) + "ms");
                    // message now contains an object with the properties specified in the .proto file
                    // console.log(message) // todo
                    // console.log("final_msg______" + message)
                });
                console.timeEnd("httpGetDecodeProto")
            } else {
                console.log(666)
            }

            console.timeEnd("httpGetParseOverhead")
            console.timeEnd("httpGetTotal")
        };

        console.time("httpGetLoadResponse")
        xmlHttp.send(null);


        // xmlHttp.responseType = "arraybuffer"
        // xmlHttp.send(null);
        // // console.log(xmlHttp.responseType)
        // // return new Uint8Array(xmlHttp.response);
        // res = xmlHttp.response
        // console.log(typeof res)
        // var uInt8Array = new Uint8Array(res); // Note:not xhr.responseText
        // console.log(res.length)
        //
        // for (var i = 0, len = res.length; i < len; ++i) {
        //     uInt8Array[i] = xmlHttp.response[i];
        // }
        // console.log(uInt8Array.length)
        //
        // return uInt8Array;
    }

    // // I retrieve the Base64 Encoded string

    // startTime = new Date();
    httpGet("/states-proto");
    // var msg = httpGet("/states");
    // console.log(msg) // todo
    // console.log("msg = " + (typeof msg)) // todo
    // console.log("msg_____")
    // /*function b64EncodeUnicode(str) {
    //     // first we use encodeURIComponent to get percent-encoded UTF-8,
    //     // then we convert the percent encodings into raw bytes which
    //     // can be fed into btoa.
    //     return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
    //         function toSolidBytes(match, p1) {
    //             return String.fromCharCode('0x' + p1);
    //         }));
    // }*/
    // // I transform such string to the typed array needed
    // // buffer = Uint8Array.from(atob(b64EncodeUnicode(msg)), c => c.charCodeAt(0))
    // // convert a Unicode string to a string in which
    // // each 16-bit unit occupies only one byte
    // /*function toBinary(string) {
    //     const codeUnits = Uint16Array.from(
    //         { length: string.length },
    //         (element, index) => string.charCodeAt(index)
    //     );
    //     const charCodes = new Uint8Array(codeUnits.buffer);
    //
    //     let result = "";
    //     charCodes.forEach((char) => {
    //         result += String.fromCharCode(char);
    //     });
    //     return result;
    // }*/
    //
    // // buffer = Uint8Array.from(atob(msg), c => c.charCodeAt(0))
    // // buffer = toUTF8Array(msg)
    // // buffer = Uint8Array.from(atob(btoa(toBinary(msg))), c => c.charCodeAt(0))
    // // buffer = Uint8Array.from(atob(unescape((msg))), c => c.charCodeAt(0))
    // // console.log(buffer) // todo
    // // console.log("buffer_____")
    // // Initiate the Protobuf library by opening the .proto file
    // protobuf.load("/statesProto.proto", function(err, root) {
    //
    //     // Retrieve the type of message I want to decode from the .proto file
    //     var MyMessage = root.lookupType("States");
    //
    //     // Finally I can decode my message
    //     var message = MyMessage.decode(msg);
    //     endTime = new Date();
    //     console.timeEnd("alias")
    //     console.log("elapsed time: " + (endTime - startTime) + "ms");
    //     // message now contains an object with the properties specified in the .proto file
    //     console.log(message) // todo
    //     console.log("final_msg______" + message)
    // });
</script>
<body>
<p th:text="'Hello, ' + ${name} + '!'"/>
</body>
</html>